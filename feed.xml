<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://jeffburg.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://jeffburg.com/" rel="alternate" type="text/html" /><updated>2025-10-11T17:55:27+00:00</updated><id>https://jeffburg.com/feed.xml</id><title type="html">Jeffrey Bergier</title><entry><title type="html">Hipstapaper</title><link href="https://jeffburg.com/apps/2017/01/01/Hipstapaper.html" rel="alternate" type="text/html" title="Hipstapaper" /><published>2017-01-01T00:00:00+00:00</published><updated>2017-01-01T00:00:00+00:00</updated><id>https://jeffburg.com/apps/2017/01/01/Hipstapaper</id><content type="html" xml:base="https://jeffburg.com/apps/2017/01/01/Hipstapaper.html"><![CDATA[<h2 id="overview">Overview</h2>

<p>Hipstapaper is an app I built for myself to save links to web pages similar to 
Instapaper which was popular in the 2012’s or so. But as Instapaper was losing
traction, I didn’t want to lose the functionality</p>

<ul>
  <li>Basic CRUD management of websites</li>
  <li>Tagging, Filtering, Sorting</li>
  <li>Bulk editing</li>
  <li>State restoration</li>
  <li>iPadOS and macOS Menus</li>
  <li>iPadOS and macOS “Scenes” for multiple window support</li>
  <li>Share extension for adding content</li>
  <li>iCloud Sync</li>
</ul>

<h3 id="download">Download</h3>

<p>I never release Hipstapaper on the AppStore but you can always use Hipstaper
on your iOS and macOS devices using the links below:</p>

<ul>
  <li><a href="https://github.com/jeffreybergier/Hipstapaper/tree/main/Releases/macOS">macOS Downloads</a></li>
  <li><a href="https://testflight.apple.com/join/V1f2j5Jd">iOS TestFlight</a></li>
  <li><a href="https://github.com/jeffreybergier/Hipstapaper/">Hipstapaper Source Code</a></li>
</ul>

<h3 id="table-of-contents">Table of Contents</h3>

<ul id="markdown-toc">
  <li><a href="#overview" id="markdown-toc-overview">Overview</a>    <ul>
      <li><a href="#download" id="markdown-toc-download">Download</a></li>
      <li><a href="#table-of-contents" id="markdown-toc-table-of-contents">Table of Contents</a></li>
    </ul>
  </li>
  <li><a href="#development" id="markdown-toc-development">Development</a>    <ul>
      <li><a href="#phase-1-2016-2018" id="markdown-toc-phase-1-2016-2018">Phase 1 (2016-2018)</a></li>
      <li><a href="#phase-2-2019-2021" id="markdown-toc-phase-2-2019-2021">Phase 2 (2019-2021)</a></li>
      <li><a href="#phase-3-2022-current" id="markdown-toc-phase-3-2022-current">Phase 3 (2022-Current)</a></li>
    </ul>
  </li>
  <li><a href="#current-status" id="markdown-toc-current-status">Current Status</a></li>
</ul>

<h2 id="development">Development</h2>

<p>Hipstapaper was a learning exercise I wanted to learn how to make a
cross-platform application that worked on all of Apple’s platforms, including
macOS. This was a big learning opportunity as I had never made an AppKit based
app before. The TL;DR is that I ended up liking AppKit even more than UIKit and
most of the toy apps I make now are either AppKit or SwiftUI.</p>

<h3 id="phase-1-2016-2018">Phase 1 (2016-2018)</h3>

<p>During this phase, there were no cross-platform UI frameworks from Apple and
there was no Database that had online syncing from Apple. Thus the technologies 
I chose were not ideal, but they were the only way to get the job done:</p>

<ol>
  <li>Cross-Platform: UIKit and AppKit UI implementations
    <ul>
      <li>Two UI implementations meant everything had to be implemented and updated
 twice. This was a big pain</li>
    </ul>
  </li>
  <li>Realm Database: Realm featured powerful sync capabilities that iCloud could
not match
    <ul>
      <li>Realm was a great database, but it was not the platform standard “Core Data”</li>
    </ul>
  </li>
  <li>Realm Sync Server: Realm-powered server running in Digital Ocean
    <ul>
      <li>Running my own server meant that I would never be able to support users for
 free. So this kept the app limited to my own personal use.</li>
    </ul>
  </li>
</ol>

<h3 id="phase-2-2019-2021">Phase 2 (2019-2021)</h3>

<p>In WWDC 2019, Apple introduced Core Data syncing via CloudKit. While Apple
pitched this as their final solution to Core Data syncing, the actual
<a href="https://developer.apple.com/videos/play/wwdc2019/202">session video</a> they
published was so quick, and so information dense that it was hard to follow.
As well, the feature has fundamental limitations, that I think have prevented
it from being very successful.</p>

<p>But with the introduction of Core Data syncing, I worked in Hipstapaper to 
swap out Realm with Core Data. This was no easy task as I had not wrapped
Realm in its own wrapper and Realm headers and tokens needs to be removed
from hundreds of UI files… two times for UIKit and AppKit.</p>

<h3 id="phase-3-2022-current">Phase 3 (2022-Current)</h3>

<p>I wanted to learn SwiftUI and because SwiftUI was finally becoming full-featured
enough to support apps with complex navigation for both iOS and macOS, I decided
to take on the challenge. This required significant updates to the Database
wrapper to support SwiftUI’s dynamic data model. However, it worked. I was able
to delete thousands of lines of platform specific UI code and replace it with
just one SwiftUI codebase. As well, I learned to love SwiftUI. If you can figure
out how to let go and let the data drive your application, SwiftUI is simply
amazing. The way the it dynamically updates when there are literally hudreds
of database changes happening every second (such as during a sync operation)
is incredible. SwiftUI is truly a gamechanger</p>

<h2 id="current-status">Current Status</h2>

<p>I still use Hipstapaper across my devices daily. However, I have never put it 
on the App Store or anything like that as I know it is missing key features
that people will want such as offline reading of webpages. Yes, the link to
the web page is stored offline in the database, but to actually open the web
page you will need an internet connection.</p>]]></content><author><name></name></author><category term="Apps" /><category term="cocoa" /><category term="cocoa-touch" /><category term="swift" /><category term="uikit" /><category term="appkit" /><summary type="html"><![CDATA[Hipstapaper was my very first cross-platform app that works on iPhone, iPad, and macOS]]></summary></entry><entry><title type="html">WaterMe: Gardening Reminders</title><link href="https://jeffburg.com/apps/2016/04/15/WaterMe.html" rel="alternate" type="text/html" title="WaterMe: Gardening Reminders" /><published>2016-04-15T00:00:00+00:00</published><updated>2016-04-15T00:00:00+00:00</updated><id>https://jeffburg.com/apps/2016/04/15/WaterMe</id><content type="html" xml:base="https://jeffburg.com/apps/2016/04/15/WaterMe.html"><![CDATA[<p>WaterMe was my first app that was 100% a CRUD app. CRUD basically means that its
a database app. It Creates, Reads, Updates, and Deletes database entries. But it
displays them in a nice way with really great animations. The premise of the app
is that, unlike reminders style apps, this app only gives you one reminder per
day letting you know which plants need to be watered that day.</p>

<p>Because of this premise, I had to do quite a lot of complex date math to figure
out which day a plant need to be watered. If your a developer, you know this can
be complex because days and time zones are pretty complex. As well, because I
don’t use a Push Notification server, I need to schedule what Apple calls “Local
Notifications,” This basically means that any time the database changes, I need
to look about 14 days ahead and figure out, for every day, if a plant needs to
be watered and which one, and then schedule 14 notifications. Anyway, I am going
too deep.</p>

<p>WaterMe has been on the app store since 2016 and has gone through many updates
and changes to improve as new features are added into the OS, such as drag and
drop which you can see in the screenshot to the left. Over the years I also
enable Core Data to CloudKit syncing for automatic and reliable iCloud sync
between devices.</p>

<p>include embed/video.html src=’{/assets/img/apps-waterme/apps-video-waterme.mp4}’</p>]]></content><author><name></name></author><category term="Apps" /><category term="cocoa" /><category term="cocoa-touch" /><category term="swift" /><category term="uikit" /><summary type="html"><![CDATA[WaterMe was my first app that was 100% a CRUD app and has been on the App Store since 2016.]]></summary></entry><entry><title type="html">QoS Redesign</title><link href="https://jeffburg.com/design/2014/01/01/QoS.html" rel="alternate" type="text/html" title="QoS Redesign" /><published>2014-01-01T00:00:00+00:00</published><updated>2014-01-01T00:00:00+00:00</updated><id>https://jeffburg.com/design/2014/01/01/QoS</id><content type="html" xml:base="https://jeffburg.com/design/2014/01/01/QoS.html"><![CDATA[<h2 id="project">Project</h2>
<p>The QoS feature of the SteelHead was being re-implemented and so it was due for
a redesign. QoS is extremely complex and the design process was long. But it was
an incredible success. Through extensive UX research and design, we proposed a
new mental model for QoS in the SteelHead.</p>

<ul id="markdown-toc">
  <li><a href="#project" id="markdown-toc-project">Project</a>    <ul>
      <li><a href="#feature-research" id="markdown-toc-feature-research">Feature Research</a></li>
      <li><a href="#user-research" id="markdown-toc-user-research">User Research</a></li>
      <li><a href="#sites" id="markdown-toc-sites">Sites</a></li>
      <li><a href="#classes" id="markdown-toc-classes">Classes</a></li>
      <li><a href="#rules" id="markdown-toc-rules">Rules</a></li>
      <li><a href="#profiles" id="markdown-toc-profiles">Profiles</a></li>
    </ul>
  </li>
  <li><a href="#experimentation" id="markdown-toc-experimentation">Experimentation</a>    <ul>
      <li><a href="#qos-class-feedback" id="markdown-toc-qos-class-feedback">QoS Class Feedback</a></li>
      <li><a href="#uplink-variations" id="markdown-toc-uplink-variations">Uplink Variations</a></li>
      <li><a href="#dashboard-widget" id="markdown-toc-dashboard-widget">Dashboard Widget</a></li>
    </ul>
  </li>
</ul>

<h3 id="feature-research">Feature Research</h3>
<p><a href="/assets/images/design/qos/feature-2k.png"><img src="/assets/images/design/qos/feature-600.png" alt="Screenshot" /></a>
QoS is an enormously complex feature. The first step in the process was to fully
understand how QoS works, what its intended to do, and what is needed to make it
do that. I learned everything from the HFSC algorithm, QoS classes, deep packet
inspection, latency priority, minimum and maximum bandwidth, etc. It got to the
point where the questions I asked of the engineers couldn’t be answered without
looking into their source code.</p>

<h3 id="user-research">User Research</h3>
<p><a href="/assets/images/design/qos/user-2k.png"><img src="/assets/images/design/qos/user-600.png" alt="Screenshot" /></a>
After learning everything there is to know about how QoS works, it was time to
speak with network administrators to see how they actually use it. I went onsite
at several companies in Illinois, Montreal, and the UK. The user researcher and
I also conducted remote interviews of many more firms. We learned what they used
QoS for, what issues they had with the current version of QoS, and what they
wanted to do with the QoS feature in the future.</p>

<h3 id="sites">Sites</h3>
<p><a href="/assets/images/design/qos/sites-2k.png"><img src="/assets/images/design/qos/sites-600.png" alt="Screenshot" /></a>
QoS needs to know the speeds of every network connection in the system. It needs
to know this so it can adequately divide up resources. Network administrators
have hundreds, or even thousands of locations. And each location can have
multiple network connections. So I created an entire concept around this called
‘Sites.’ Each site has any number of uplinks (network connections) and each
uplink has upstream and downstream bandwidths associated with them. This gives
the QoS system the information it needs on bandwidth restrictions across the
entire network.</p>

<h3 id="classes">Classes</h3>
<p><a href="/assets/images/design/qos/classes-2k.png"><img src="/assets/images/design/qos/classes-600.png" alt="Screenshot" /></a>
QoS systems usually have the concept of classes. Classes are sort of like
buckets. The network administrator puts certain applications into certain
buckets, then the system treats each bucket with a certain level of importance.
The most important thing to remember about these buckets, is that giving one
more resources, necessarily gives the others less. Also, putting all traffic
into an important bucket may not be desirable. QoS works by prioritizing
important traffic over less important traffic. If all traffic is marked as
important, it can’t do that. Concerns like this were common from network
administrators. I attempted to produce UI’s that could show some of this
information in a visual way, but in the end, we settled for a fairly simple tree
visualization. A few slides after this, there are some concepts I made for
visually showing class information.</p>

<h3 id="rules">Rules</h3>
<p><a href="/assets/images/design/qos/classes-2k.png"><img src="/assets/images/design/qos/classes-600.png" alt="Screenshot" /></a>
QoS classes are like buckets you put Apps into that then get managed by the QoS
system. Rules are the mechanism by which the network administrator puts apps
into the classes. Because SteelHead has incredibly powerful Deep Packet
Inspection (DPI) technology. Specifying apps is very easy. Users can search for
commonly known app names, as opposed to intricate IP address and port mappings.
Also, our team pre-grouped the apps into about 8 groups. Each group contains
approximately 800 applications. The rules can be specified with an individual
app or an individual app group. This makes configuring QoS extremely fast.</p>

<h3 id="profiles">Profiles</h3>
<p><a href="/assets/images/design/qos/profiles-2k.png"><img src="/assets/images/design/qos/profiles-600.png" alt="Screenshot" /></a>
QoS profiles are how you connect QoS Classes and Rules and Sites. The
SteelCentral Controller has a birds-eye view of all the SteelHeads on a
customer’s network. We designed the profiles UI to take advantage of this extra
knowledge. We did this by having the network administrator choose a source and
destination site, or group of sites, that each profile applies to. With this
information, the SteelCentral Controller knows how to distribute the QoS
Profiles to all appliances automatically. This simplification makes QoS
configuration far more declarative. This is something we strive for. We call it
‘intent’ based management. Where the network administrator specifies <strong>what</strong>
they want, rather than <strong>how</strong> to make it happen. This is an incredibly powerful
paradigm for the new QoS feature.</p>

<h2 id="experimentation">Experimentation</h2>
<p>As with all products and features, not everything the design team makes, makes
it into the product. Sometimes they’re features that are not needed, sometimes
they are too complex, and sometimes they are just way too cool. Below are some
experiments that I made that never shipped.</p>

<h3 id="qos-class-feedback">QoS Class Feedback</h3>
<p><a href="/assets/images/design/qos/profile-experiment1-2k.png"><img src="/assets/images/design/qos/profile-experiment1-600.png" alt="Screenshot" /></a>
Setting the min and max bandwidth allocations for a QoS class is kind of a
guessing game. Set the numbers and see how it goes. In order to alleviate
this, I attempted to create some mockups with configurations that would
advise the user of issues with the classes and tried to summarize their
congestion over time in a visual way.</p>

<h3 id="uplink-variations">Uplink Variations</h3>
<p><a href="/assets/images/design/qos/profile-experiment2-2k.png"><img src="/assets/images/design/qos/profile-experiment2-600.png" alt="Screenshot" /></a>
Uplink Variations are a system where the network admin could select
different QoS Class min and max assignments based on the Uplink that was
being used. This is important when one or more network connections fail at a
site. In those conditions, critical traffic needs a higher priority.</p>

<h3 id="dashboard-widget">Dashboard Widget</h3>
<p><a href="/assets/images/design/qos/dashboard-experiment-2k.png"><img src="/assets/images/design/qos/dashboard-experiment-600.png" alt="Screenshot" /></a>
SteelCentral Controller has really great dashboards that give an overview of
what is going on on your network. This is one mockups I made of what a QoS
widget could have looked at. It shows the QoS classes. When a class is
expanded, it shows relevant errors and warnings.</p>]]></content><author><name></name></author><category term="Design" /><summary type="html"><![CDATA[Redesign QoS on SteelHead and SteelCentral Controller for greater flexibility and improved simplicity.]]></summary></entry></feed>