<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://jeffburg.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://jeffburg.com/" rel="alternate" type="text/html" /><updated>2025-10-13T07:12:23+00:00</updated><id>https://jeffburg.com/feed.xml</id><title type="html">Jeffrey Bergier</title><entry><title type="html">Hipstapaper</title><link href="https://jeffburg.com/apps/2017/01/01/Hipstapaper.html" rel="alternate" type="text/html" title="Hipstapaper" /><published>2017-01-01T00:00:00+00:00</published><updated>2017-01-01T00:00:00+00:00</updated><id>https://jeffburg.com/apps/2017/01/01/Hipstapaper</id><content type="html" xml:base="https://jeffburg.com/apps/2017/01/01/Hipstapaper.html"><![CDATA[<h2 id="overview">Overview</h2>

<p>Hipstapaper is an app I built for myself to save links to web pages similar to 
Instapaper which was popular in the 2012’s or so. But as Instapaper was losing
traction, I didn’t want to lose the functionality</p>

<ul>
  <li>Basic CRUD management of websites</li>
  <li>Tagging, Filtering, Sorting</li>
  <li>Bulk editing</li>
  <li>State restoration</li>
  <li>iPadOS and macOS Menus</li>
  <li>iPadOS and macOS “Scenes” for multiple window support</li>
  <li>Share extension for adding content</li>
  <li>iCloud Sync</li>
</ul>

<h3 id="download">Download</h3>

<p>I never release Hipstapaper on the AppStore but you can always use Hipstaper
on your iOS and macOS devices using the links below:</p>

<ul>
  <li><a href="https://github.com/jeffreybergier/Hipstapaper/tree/main/Releases/macOS"><i class="fa-regular fa-circle-down"></i>macOS Downloads</a></li>
  <li><a href="https://testflight.apple.com/join/V1f2j5Jd"><i class="fa-brands fa-app-store"></i>iOS TestFlight</a></li>
  <li><a href="https://github.com/jeffreybergier/Hipstapaper/"><i class="fa-brands fa-github"></i>Hipstapaper Source Code</a></li>
</ul>

<h3 id="table-of-contents">Table of Contents</h3>

<ul id="markdown-toc">
  <li><a href="#overview" id="markdown-toc-overview">Overview</a>    <ul>
      <li><a href="#download" id="markdown-toc-download">Download</a></li>
      <li><a href="#table-of-contents" id="markdown-toc-table-of-contents">Table of Contents</a></li>
    </ul>
  </li>
  <li><a href="#development" id="markdown-toc-development">Development</a>    <ul>
      <li><a href="#phase-1-2016-2018" id="markdown-toc-phase-1-2016-2018">Phase 1 (2016-2018)</a></li>
      <li><a href="#phase-2-2019-2021" id="markdown-toc-phase-2-2019-2021">Phase 2 (2019-2021)</a></li>
      <li><a href="#phase-3-2022-current" id="markdown-toc-phase-3-2022-current">Phase 3 (2022-Current)</a></li>
    </ul>
  </li>
  <li><a href="#current-status" id="markdown-toc-current-status">Current Status</a></li>
</ul>

<h2 id="development">Development</h2>

<p>Hipstapaper was a learning exercise I wanted to learn how to make a
cross-platform application that worked on all of Apple’s platforms, including
macOS. This was a big learning opportunity as I had never made an AppKit based
app before. The TL;DR is that I ended up liking AppKit even more than UIKit and
most of the toy apps I make now are either AppKit or SwiftUI.</p>

<h3 id="phase-1-2016-2018">Phase 1 (2016-2018)</h3>

<p>During this phase, there were no cross-platform UI frameworks from Apple and
there was no Database that had online syncing from Apple. Thus the technologies 
I chose were not ideal, but they were the only way to get the job done:</p>

<ol>
  <li>Cross-Platform: UIKit and AppKit UI implementations
    <ul>
      <li>Two UI implementations meant everything had to be implemented and updated
 twice. This was a big pain</li>
    </ul>
  </li>
  <li>Realm Database: Realm featured powerful sync capabilities that iCloud could
not match
    <ul>
      <li>Realm was a great database, but it was not the platform standard “Core Data”</li>
    </ul>
  </li>
  <li>Realm Sync Server: Realm-powered server running in Digital Ocean
    <ul>
      <li>Running my own server meant that I would never be able to support users for
 free. So this kept the app limited to my own personal use.</li>
    </ul>
  </li>
</ol>

<h3 id="phase-2-2019-2021">Phase 2 (2019-2021)</h3>

<p>In WWDC 2019, Apple introduced Core Data syncing via CloudKit. While Apple
pitched this as their final solution to Core Data syncing, the actual
<a href="https://developer.apple.com/videos/play/wwdc2019/202">session video</a> they
published was so quick, and so information dense that it was hard to follow.
As well, the feature has fundamental limitations, that I think have prevented
it from being very successful.</p>

<p>But with the introduction of Core Data syncing, I worked in Hipstapaper to 
swap out Realm with Core Data. This was no easy task as I had not wrapped
Realm in its own wrapper and Realm headers and tokens needs to be removed
from hundreds of UI files… two times for UIKit and AppKit.</p>

<h3 id="phase-3-2022-current">Phase 3 (2022-Current)</h3>

<p>I wanted to learn SwiftUI and because SwiftUI was finally becoming full-featured
enough to support apps with complex navigation for both iOS and macOS, I decided
to take on the challenge. This required significant updates to the Database
wrapper to support SwiftUI’s dynamic data model. However, it worked. I was able
to delete thousands of lines of platform specific UI code and replace it with
just one SwiftUI codebase. As well, I learned to love SwiftUI. If you can figure
out how to let go and let the data drive your application, SwiftUI is simply
amazing. The way the it dynamically updates when there are literally hudreds
of database changes happening every second (such as during a sync operation)
is incredible. SwiftUI is truly a gamechanger</p>

<h2 id="current-status">Current Status</h2>

<p>I still use Hipstapaper across my devices daily. However, I have never put it 
on the App Store or anything like that as I know it is missing key features
that people will want such as offline reading of webpages. Yes, the link to
the web page is stored offline in the database, but to actually open the web
page you will need an internet connection.</p>]]></content><author><name></name></author><category term="Apps" /><category term="cocoa" /><category term="cocoa-touch" /><category term="swift" /><category term="uikit" /><category term="appkit" /><summary type="html"><![CDATA[Hipstapaper was my very first cross-platform app that works on iPhone, iPad, and macOS]]></summary></entry><entry><title type="html">WaterMe: Gardening Reminders</title><link href="https://jeffburg.com/apps/2016/04/15/WaterMe.html" rel="alternate" type="text/html" title="WaterMe: Gardening Reminders" /><published>2016-04-15T00:00:00+00:00</published><updated>2016-04-15T00:00:00+00:00</updated><id>https://jeffburg.com/apps/2016/04/15/WaterMe</id><content type="html" xml:base="https://jeffburg.com/apps/2016/04/15/WaterMe.html"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>

<ul id="markdown-toc">
  <li><a href="#table-of-contents" id="markdown-toc-table-of-contents">Table of Contents</a></li>
  <li><a href="#overview" id="markdown-toc-overview">Overview</a>    <ul>
      <li><a href="#app-store-description" id="markdown-toc-app-store-description">App Store Description</a></li>
      <li><a href="#download" id="markdown-toc-download">Download</a></li>
    </ul>
  </li>
  <li><a href="#development" id="markdown-toc-development">Development</a>    <ul>
      <li><a href="#version-1-2016" id="markdown-toc-version-1-2016">Version 1 (2016)</a></li>
      <li><a href="#phase-2-2019-2021" id="markdown-toc-phase-2-2019-2021">Phase 2 (2019-2021)</a></li>
      <li><a href="#phase-3-2022-current" id="markdown-toc-phase-3-2022-current">Phase 3 (2022-Current)</a></li>
    </ul>
  </li>
  <li><a href="#current-status" id="markdown-toc-current-status">Current Status</a></li>
</ul>

<h2 id="overview">Overview</h2>

<p>WaterMe is the only app that I have released on the App Store that got any sort
of usage traction at all. It doesn’t have a lot of users, but at the time of
this writing (September 2025) it had 993K total sessions according to App Store
Connect analytics. Since these analytics are opt-in I assume that means its had
about 3M total sessions… which is still not a lot, but for a nice little hobby
app, I think its pretty cool <i class="fa-regular fa-hand-peace"></i></p>

<h3 id="app-store-description">App Store Description</h3>

<p>Never let another plant turn brown again. WaterMe reminds you when to tend to
the plants in your garden:</p>

<ol>
  <li>Add your plants into the app.</li>
  <li>Add reminders for watering, fertilizing, etc.</li>
  <li>Get 1 notification every day reminding you which plants need care.</li>
  <li>Take care of the plant in real life.</li>
  <li>Drag and drop the reminder to mark it as complete.</li>
</ol>

<p>Thats it! Every day you’ll get one, and only one, notification that reminds you
to take care of your plants.</p>

<ul>
  <li>Supports multiple kinds of reminders per plant
    <ul>
      <li>Water, Fertilize, Trim, and more</li>
    </ul>
  </li>
  <li>Easy to see which plants need to be taken care of and when.</li>
  <li>Syncs data across all of your iOS devices via iCloud.</li>
  <li>Supports working quickly with Drag and Drop interface.</li>
  <li>Customize the time notifications are sent every day.</li>
  <li>Care for your garden with your voice using Siri Shortcuts.</li>
  <li>Tip Jar In-App Purchases allow you to directly support the development of WaterMe.</li>
  <li>Supports Split Screen and Slide Over iPad Multitasking.</li>
  <li>Supports Dynamic Type.</li>
  <li>Supports Voiceover and other iOS accessibility features.</li>
</ul>

<h3 id="download">Download</h3>

<ul>
  <li><a href="https://apps.apple.com/us/app/waterme-gardening-reminders/id1089742494" target="_blank"><i class="fa-brands fa-app-store"></i>App Store</a></li>
  <li><a href="https://github.com/jeffreybergier/WaterMe/" target="_blank"><i class="fa-brands fa-github"></i>WaterMe Source Code</a></li>
  <li><a href="https://bitbucket.org/saturdayapps/waterme/" target="_blank"><i class="fa-brands fa-bitbucket"></i>WaterMe Source Code (Outdated)</a></li>
</ul>

<h2 id="development">Development</h2>

<p>WaterMe was the first ever app I wrote that is 100% a <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> 
app. Its just a database app with a pretty user interface placed on top of it.
I also got help from a designer friend to make the watering animation video as
well as the icon. Its written entirely in Swift and UIKit but has gone through
a lot of iterations over the years.</p>

<h3 id="version-1-2016">Version 1 (2016)</h3>

<p>The original version of WaterMe was extremely simple and the Core Data model was
simple to match. You had a plant with a name, photo, last watered date, and
watering interval. The app would then sort them categorize them as needing
“Water Today”, “Water Tomorrow”, or “Water Later.” As this was the days of iOS
7, the user interface was also extremely simple.</p>

<table>
  <tbody>
    <tr>
      <td><a href="/assets/images/apps/waterme/v1/01-full.png"><img src="/assets/images/apps/waterme/v1/01-thumb.png" alt="WaterMe v1 Screenshot 1" /></a></td>
      <td><a href="/assets/images/apps/waterme/v1/02-full.png"><img src="/assets/images/apps/waterme/v1/02-thumb.png" alt="WaterMe v1 Screenshot 2" /></a></td>
      <td><a href="/assets/images/apps/waterme/v1/03-full.png"><img src="/assets/images/apps/waterme/v1/03-thumb.png" alt="WaterMe v1 Screenshot 3" /></a></td>
      <td><a href="/assets/images/apps/waterme/v1/04-full.png"><img src="/assets/images/apps/waterme/v1/04-thumb.png" alt="WaterMe v1 Screenshot 4" /></a></td>
      <td><a href="/assets/images/apps/waterme/v1/05-full.png"><img src="/assets/images/apps/waterme/v1/05-thumb.png" alt="WaterMe v1 Screenshot 5" /></a></td>
    </tr>
  </tbody>
</table>

<h3 id="phase-2-2019-2021">Phase 2 (2019-2021)</h3>

<p>A</p>

<h3 id="phase-3-2022-current">Phase 3 (2022-Current)</h3>

<p>A</p>

<h2 id="current-status">Current Status</h2>

<p>A</p>

<p>include embed/video.html src=’{/assets/img/apps-waterme/apps-video-waterme.mp4}’</p>]]></content><author><name></name></author><category term="Apps" /><category term="cocoa" /><category term="cocoa-touch" /><category term="swift" /><category term="uikit" /><summary type="html"><![CDATA[WaterMe was my first app that was 100% a CRUD app and has been on the App Store since 2016.]]></summary></entry><entry><title type="html">QoS Redesign</title><link href="https://jeffburg.com/design/2014/01/01/QoS.html" rel="alternate" type="text/html" title="QoS Redesign" /><published>2014-01-01T00:00:00+00:00</published><updated>2014-01-01T00:00:00+00:00</updated><id>https://jeffburg.com/design/2014/01/01/QoS</id><content type="html" xml:base="https://jeffburg.com/design/2014/01/01/QoS.html"><![CDATA[<h2 id="project">Project</h2>
<p>The QoS feature of the SteelHead was being re-implemented and so it was due for
a redesign. QoS is extremely complex and the design process was long. But it was
an incredible success. Through extensive UX research and design, we proposed a
new mental model for QoS in the SteelHead.</p>

<ul id="markdown-toc">
  <li><a href="#project" id="markdown-toc-project">Project</a>    <ul>
      <li><a href="#feature-research" id="markdown-toc-feature-research">Feature Research</a></li>
      <li><a href="#user-research" id="markdown-toc-user-research">User Research</a></li>
      <li><a href="#sites" id="markdown-toc-sites">Sites</a></li>
      <li><a href="#classes" id="markdown-toc-classes">Classes</a></li>
      <li><a href="#rules" id="markdown-toc-rules">Rules</a></li>
      <li><a href="#profiles" id="markdown-toc-profiles">Profiles</a></li>
    </ul>
  </li>
  <li><a href="#experimentation" id="markdown-toc-experimentation">Experimentation</a>    <ul>
      <li><a href="#qos-class-feedback" id="markdown-toc-qos-class-feedback">QoS Class Feedback</a></li>
      <li><a href="#uplink-variations" id="markdown-toc-uplink-variations">Uplink Variations</a></li>
      <li><a href="#dashboard-widget" id="markdown-toc-dashboard-widget">Dashboard Widget</a></li>
    </ul>
  </li>
</ul>

<h3 id="feature-research">Feature Research</h3>
<p><a href="/assets/images/design/qos/feature-2k.png"><img src="/assets/images/design/qos/feature-600.png" alt="Screenshot" /></a>
QoS is an enormously complex feature. The first step in the process was to fully
understand how QoS works, what its intended to do, and what is needed to make it
do that. I learned everything from the HFSC algorithm, QoS classes, deep packet
inspection, latency priority, minimum and maximum bandwidth, etc. It got to the
point where the questions I asked of the engineers couldn’t be answered without
looking into their source code.</p>

<h3 id="user-research">User Research</h3>
<p><a href="/assets/images/design/qos/user-2k.png"><img src="/assets/images/design/qos/user-600.png" alt="Screenshot" /></a>
After learning everything there is to know about how QoS works, it was time to
speak with network administrators to see how they actually use it. I went onsite
at several companies in Illinois, Montreal, and the UK. The user researcher and
I also conducted remote interviews of many more firms. We learned what they used
QoS for, what issues they had with the current version of QoS, and what they
wanted to do with the QoS feature in the future.</p>

<h3 id="sites">Sites</h3>
<p><a href="/assets/images/design/qos/sites-2k.png"><img src="/assets/images/design/qos/sites-600.png" alt="Screenshot" /></a>
QoS needs to know the speeds of every network connection in the system. It needs
to know this so it can adequately divide up resources. Network administrators
have hundreds, or even thousands of locations. And each location can have
multiple network connections. So I created an entire concept around this called
‘Sites.’ Each site has any number of uplinks (network connections) and each
uplink has upstream and downstream bandwidths associated with them. This gives
the QoS system the information it needs on bandwidth restrictions across the
entire network.</p>

<h3 id="classes">Classes</h3>
<p><a href="/assets/images/design/qos/classes-2k.png"><img src="/assets/images/design/qos/classes-600.png" alt="Screenshot" /></a>
QoS systems usually have the concept of classes. Classes are sort of like
buckets. The network administrator puts certain applications into certain
buckets, then the system treats each bucket with a certain level of importance.
The most important thing to remember about these buckets, is that giving one
more resources, necessarily gives the others less. Also, putting all traffic
into an important bucket may not be desirable. QoS works by prioritizing
important traffic over less important traffic. If all traffic is marked as
important, it can’t do that. Concerns like this were common from network
administrators. I attempted to produce UI’s that could show some of this
information in a visual way, but in the end, we settled for a fairly simple tree
visualization. A few slides after this, there are some concepts I made for
visually showing class information.</p>

<h3 id="rules">Rules</h3>
<p><a href="/assets/images/design/qos/classes-2k.png"><img src="/assets/images/design/qos/classes-600.png" alt="Screenshot" /></a>
QoS classes are like buckets you put Apps into that then get managed by the QoS
system. Rules are the mechanism by which the network administrator puts apps
into the classes. Because SteelHead has incredibly powerful Deep Packet
Inspection (DPI) technology. Specifying apps is very easy. Users can search for
commonly known app names, as opposed to intricate IP address and port mappings.
Also, our team pre-grouped the apps into about 8 groups. Each group contains
approximately 800 applications. The rules can be specified with an individual
app or an individual app group. This makes configuring QoS extremely fast.</p>

<h3 id="profiles">Profiles</h3>
<p><a href="/assets/images/design/qos/profiles-2k.png"><img src="/assets/images/design/qos/profiles-600.png" alt="Screenshot" /></a>
QoS profiles are how you connect QoS Classes and Rules and Sites. The
SteelCentral Controller has a birds-eye view of all the SteelHeads on a
customer’s network. We designed the profiles UI to take advantage of this extra
knowledge. We did this by having the network administrator choose a source and
destination site, or group of sites, that each profile applies to. With this
information, the SteelCentral Controller knows how to distribute the QoS
Profiles to all appliances automatically. This simplification makes QoS
configuration far more declarative. This is something we strive for. We call it
‘intent’ based management. Where the network administrator specifies <strong>what</strong>
they want, rather than <strong>how</strong> to make it happen. This is an incredibly powerful
paradigm for the new QoS feature.</p>

<h2 id="experimentation">Experimentation</h2>
<p>As with all products and features, not everything the design team makes, makes
it into the product. Sometimes they’re features that are not needed, sometimes
they are too complex, and sometimes they are just way too cool. Below are some
experiments that I made that never shipped.</p>

<h3 id="qos-class-feedback">QoS Class Feedback</h3>
<p><a href="/assets/images/design/qos/profile-experiment1-2k.png"><img src="/assets/images/design/qos/profile-experiment1-600.png" alt="Screenshot" /></a>
Setting the min and max bandwidth allocations for a QoS class is kind of a
guessing game. Set the numbers and see how it goes. In order to alleviate
this, I attempted to create some mockups with configurations that would
advise the user of issues with the classes and tried to summarize their
congestion over time in a visual way.</p>

<h3 id="uplink-variations">Uplink Variations</h3>
<p><a href="/assets/images/design/qos/profile-experiment2-2k.png"><img src="/assets/images/design/qos/profile-experiment2-600.png" alt="Screenshot" /></a>
Uplink Variations are a system where the network admin could select
different QoS Class min and max assignments based on the Uplink that was
being used. This is important when one or more network connections fail at a
site. In those conditions, critical traffic needs a higher priority.</p>

<h3 id="dashboard-widget">Dashboard Widget</h3>
<p><a href="/assets/images/design/qos/dashboard-experiment-2k.png"><img src="/assets/images/design/qos/dashboard-experiment-600.png" alt="Screenshot" /></a>
SteelCentral Controller has really great dashboards that give an overview of
what is going on on your network. This is one mockups I made of what a QoS
widget could have looked at. It shows the QoS classes. When a class is
expanded, it shows relevant errors and warnings.</p>]]></content><author><name></name></author><category term="Design" /><summary type="html"><![CDATA[Redesign QoS on SteelHead and SteelCentral Controller for greater flexibility and improved simplicity.]]></summary></entry></feed>