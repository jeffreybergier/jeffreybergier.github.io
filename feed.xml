<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://jeffburg.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://jeffburg.com/" rel="alternate" type="text/html" /><updated>2025-10-25T04:03:25+00:00</updated><id>https://jeffburg.com/feed.xml</id><title type="html">Jeffrey Bergier</title><entry><title type="html">Teskemon: Tailscale Specialist</title><link href="https://jeffburg.com/apps/2025/02/14/Teskemon.html" rel="alternate" type="text/html" title="Teskemon: Tailscale Specialist" /><published>2025-02-14T00:00:00+00:00</published><updated>2025-02-14T00:00:00+00:00</updated><id>https://jeffburg.com/apps/2025/02/14/Teskemon</id><content type="html" xml:base="https://jeffburg.com/apps/2025/02/14/Teskemon.html"><![CDATA[<p><a href="/assets/images/apps/teskemon/01-full.png"><img src="/assets/images/apps/teskemon/01-thumb.png" alt="Teskemon Main Window" /></a></p>

<h2 id="table-of-contents">Table of Contents</h2>

<ul id="markdown-toc">
  <li><a href="#table-of-contents" id="markdown-toc-table-of-contents">Table of Contents</a></li>
  <li><a href="#overview" id="markdown-toc-overview">Overview</a>    <ul>
      <li><a href="#download" id="markdown-toc-download">Download</a></li>
    </ul>
  </li>
  <li><a href="#development" id="markdown-toc-development">Development</a>    <ul>
      <li><a href="#model" id="markdown-toc-model">Model</a></li>
      <li><a href="#controller" id="markdown-toc-controller">Controller</a></li>
      <li><a href="#view" id="markdown-toc-view">View</a></li>
      <li><a href="#privacy" id="markdown-toc-privacy">Privacy</a></li>
    </ul>
  </li>
</ul>

<h2 id="overview">Overview</h2>

<p><a href="/assets/images/apps/teskemon/02-full.png" class="thumbnail"><img src="/assets/images/apps/teskemon/02-thumb.png" alt="Teskemon About Window" /></a>
Teskemon is a SwiftUI application built to monitor Tailscale networks. 
It is provided under the <a href="LICENSE">GPLv3 open source license</a> and without any warranty or liability. 
If this application is useful for you, please use as you wish and provide feedback. 
And yes, I do accept pull requests.</p>

<h3 id="download">Download</h3>

<ul>
  <li><a href="https://github.com/jeffreybergier/Teskemon/tree/main/Builds"><i class="fa-regular fa-circle-down"></i>Teskemon Notarized Builds</a></li>
  <li><a href="https://github.com/jeffreybergier/Teskemon/" target="_blank"><i class="fa-brands fa-github"></i>Teskemon Source Code</a></li>
  <li><a href="https://jeffburg.social/tags/Tailscale" target="_blank"><i class="fa-brands fa-mastodon"></i>Teskemon Development Updates</a></li>
</ul>

<p>Requires macOS 14.4 or later because of <a href="https://developer.apple.com/documentation/swiftui/tablecolumnforeach"><code class="language-plaintext highlighter-rouge">TableColumnForEach</code></a></p>

<h2 id="development">Development</h2>

<p>Teskemon was the first app I developed to make heavy use of the new 
<a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/concurrency/">Swift Concurrency</a> 
system. Concurrency is used to ping and check open ports on many network
endpoints at once. That said, Teskemon uses a standard (boring) Model View
Controller approach. There are 3 Swift Packages, Model, Controller, View. When I
make big changes I usually post about it on Mastodon. Following along
<a href="https://jeffburg.social/tags/Tailscale">jeffburg.social/tags/Tailscale</a> if you
are curious.</p>

<h3 id="model">Model</h3>
<p>Contains all the basic model types and the conversion logic from the JSON
provided by Tailscale <code class="language-plaintext highlighter-rouge">tailscale status --json</code>. These types can all be
considered View Models if you like… they are all meant for the view.</p>

<h3 id="controller">Controller</h3>
<p>Controller contains 3 sets of functionality:</p>
<ol>
  <li>Keychain access logic</li>
  <li>Extension to Process (previously NSTask) to execute the CLI commands
and parse the results. This is all done using <code class="language-plaintext highlighter-rouge">async await</code></li>
  <li>Property Wrappers that wrap the model complexity as well as the Keychain, 
Process, and Presentation complexity into simple types the views can read from
and write to</li>
</ol>

<p>In order to ensure consistency and live updating across all screens all the time
either AppStorage or SceneStorage are used as an underlying storage primitive.
AppStorage stores settings like custom names and the list of services.
SceneStorage stores temporary information like the list of Machines from
Tailscale, the results of the Service scans, and the presentation state of all
the views.</p>

<h3 id="view">View</h3>
<p>This layer contains all of the views for the application. They are all fairly
simply and mostly consist of Tables or Forms.</p>

<h3 id="privacy">Privacy</h3>
<p>Teskemon does not access the internet or use any analytics service. There is no 
login or other user information stored. The tailscale CLI does provide your 
name, but it is only stored in SceneStorage and never uploaded anywhere. 
Passwords are stored in the keychain but they are cached in memory 
for performance reasons.</p>

<p>That said, Teskemon is not sandboxed because it uses the Process API (previously
NSTask). Because Process allows the application to run any executable on the
machine, it is not possible to use this API in a sandboxed application. Process
is only used to run netcat, ping, and the Tailscale CLI.</p>

<p>Also, if your employer tightly monitors their network, using Netcat 
to port scan a large number of ports on a large number of machines can cause 
warnings to go off (ask how I know). In those cases you may want to disable 
automatic refresh of Services, which is the default setting.</p>]]></content><author><name></name></author><category term="Apps" /><category term="Apps" /><category term="Hobby" /><summary type="html"><![CDATA[In 2024 I started using Tailscale to access my home network remotely. When I noticed Tailscale had a CLI with a JSON interface, I couldn't help myself… I built an app.]]></summary></entry><entry><title type="html">Hipstapaper: Cross Platform Reading List</title><link href="https://jeffburg.com/apps/2017/01/01/Hipstapaper.html" rel="alternate" type="text/html" title="Hipstapaper: Cross Platform Reading List" /><published>2017-01-01T00:00:00+00:00</published><updated>2017-01-01T00:00:00+00:00</updated><id>https://jeffburg.com/apps/2017/01/01/Hipstapaper</id><content type="html" xml:base="https://jeffburg.com/apps/2017/01/01/Hipstapaper.html"><![CDATA[<h2 id="overview">Overview</h2>

<p>Hipstapaper is an app I built for myself to save links to web pages similar to 
Instapaper which was popular in the 2012’s or so. But as Instapaper was losing
traction, I didn’t want to lose the functionality</p>

<ul>
  <li>Basic CRUD management of websites</li>
  <li>Tagging, Filtering, Sorting</li>
  <li>Bulk editing</li>
  <li>State restoration</li>
  <li>iPadOS and macOS Menus</li>
  <li>iPadOS and macOS “Scenes” for multiple window support</li>
  <li>Share extension for adding content</li>
  <li>iCloud Sync</li>
</ul>

<h3 id="download">Download</h3>

<p>I never release Hipstapaper on the AppStore but you can always use Hipstaper
on your iOS and macOS devices using the links below:</p>

<ul>
  <li><a href="https://github.com/jeffreybergier/Hipstapaper/tree/main/Releases/macOS"><i class="fa-regular fa-circle-down"></i>macOS Downloads</a></li>
  <li><a href="https://testflight.apple.com/join/V1f2j5Jd"><i class="fa-brands fa-app-store"></i>iOS TestFlight</a></li>
  <li><a href="https://github.com/jeffreybergier/Hipstapaper/"><i class="fa-brands fa-github"></i>Hipstapaper Source Code</a></li>
</ul>

<h3 id="table-of-contents">Table of Contents</h3>

<ul id="markdown-toc">
  <li><a href="#overview" id="markdown-toc-overview">Overview</a>    <ul>
      <li><a href="#download" id="markdown-toc-download">Download</a></li>
      <li><a href="#table-of-contents" id="markdown-toc-table-of-contents">Table of Contents</a></li>
    </ul>
  </li>
  <li><a href="#development" id="markdown-toc-development">Development</a>    <ul>
      <li><a href="#phase-1-2016-2018" id="markdown-toc-phase-1-2016-2018">Phase 1 (2016-2018)</a></li>
      <li><a href="#phase-2-2019-2021" id="markdown-toc-phase-2-2019-2021">Phase 2 (2019-2021)</a></li>
      <li><a href="#phase-3-2022-current" id="markdown-toc-phase-3-2022-current">Phase 3 (2022-Current)</a></li>
    </ul>
  </li>
  <li><a href="#current-status" id="markdown-toc-current-status">Current Status</a></li>
</ul>

<h2 id="development">Development</h2>

<p>Hipstapaper was a learning exercise I wanted to learn how to make a
cross-platform application that worked on all of Apple’s platforms, including
macOS. This was a big learning opportunity as I had never made an AppKit based
app before. The TL;DR is that I ended up liking AppKit even more than UIKit and
most of the toy apps I make now are either AppKit or SwiftUI.</p>

<h3 id="phase-1-2016-2018">Phase 1 (2016-2018)</h3>

<p>During this phase, there were no cross-platform UI frameworks from Apple and
there was no Database that had online syncing from Apple. Thus the technologies 
I chose were not ideal, but they were the only way to get the job done:</p>

<ol>
  <li>Cross-Platform: UIKit and AppKit UI implementations
    <ul>
      <li>Two UI implementations meant everything had to be implemented and updated
 twice. This was a big pain</li>
    </ul>
  </li>
  <li>Realm Database: Realm featured powerful sync capabilities that iCloud could
not match
    <ul>
      <li>Realm was a great database, but it was not the platform standard “Core Data”</li>
    </ul>
  </li>
  <li>Realm Sync Server: Realm-powered server running in Digital Ocean
    <ul>
      <li>Running my own server meant that I would never be able to support users for
 free. So this kept the app limited to my own personal use.</li>
    </ul>
  </li>
</ol>

<h3 id="phase-2-2019-2021">Phase 2 (2019-2021)</h3>

<p>In WWDC 2019, Apple introduced Core Data syncing via CloudKit. While Apple
pitched this as their final solution to Core Data syncing, the actual
<a href="https://developer.apple.com/videos/play/wwdc2019/202">session video</a> they
published was so quick, and so information dense that it was hard to follow.
As well, the feature has fundamental limitations, that I think have prevented
it from being very successful.</p>

<p>But with the introduction of Core Data syncing, I worked in Hipstapaper to 
swap out Realm with Core Data. This was no easy task as I had not wrapped
Realm in its own wrapper and Realm headers and tokens needs to be removed
from hundreds of UI files… two times for UIKit and AppKit.</p>

<h3 id="phase-3-2022-current">Phase 3 (2022-Current)</h3>

<p>I wanted to learn SwiftUI and because SwiftUI was finally becoming full-featured
enough to support apps with complex navigation for both iOS and macOS, I decided
to take on the challenge. This required significant updates to the Database
wrapper to support SwiftUI’s dynamic data model. However, it worked. I was able
to delete thousands of lines of platform specific UI code and replace it with
just one SwiftUI codebase. As well, I learned to love SwiftUI. If you can figure
out how to let go and let the data drive your application, SwiftUI is simply
amazing. The way the it dynamically updates when there are literally hudreds
of database changes happening every second (such as during a sync operation)
is incredible. SwiftUI is truly a gamechanger</p>

<h2 id="current-status">Current Status</h2>

<p>I still use Hipstapaper across my devices daily. However, I have never put it 
on the App Store or anything like that as I know it is missing key features
that people will want such as offline reading of webpages. Yes, the link to
the web page is stored offline in the database, but to actually open the web
page you will need an internet connection.</p>]]></content><author><name></name></author><category term="Apps" /><category term="Apps" /><category term="Hobby" /><summary type="html"><![CDATA[Hipstapaper was my very first cross-platform app that works on iPhone, iPad, and macOS]]></summary></entry><entry><title type="html">WaterMe: Gardening Reminders</title><link href="https://jeffburg.com/apps/2016/04/15/WaterMe.html" rel="alternate" type="text/html" title="WaterMe: Gardening Reminders" /><published>2016-04-15T00:00:00+00:00</published><updated>2016-04-15T00:00:00+00:00</updated><id>https://jeffburg.com/apps/2016/04/15/WaterMe</id><content type="html" xml:base="https://jeffburg.com/apps/2016/04/15/WaterMe.html"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>

<ul id="markdown-toc">
  <li><a href="#table-of-contents" id="markdown-toc-table-of-contents">Table of Contents</a></li>
  <li><a href="#overview" id="markdown-toc-overview">Overview</a>    <ul>
      <li><a href="#app-store-description" id="markdown-toc-app-store-description">App Store Description</a></li>
      <li><a href="#download" id="markdown-toc-download">Download</a></li>
    </ul>
  </li>
  <li><a href="#development" id="markdown-toc-development">Development</a>    <ul>
      <li><a href="#version-1-2016" id="markdown-toc-version-1-2016">Version 1 (2016)</a></li>
      <li><a href="#version-2-2017" id="markdown-toc-version-2-2017">Version 2 (2017)</a></li>
      <li><a href="#version-25-2020" id="markdown-toc-version-25-2020">Version 2.5 (2020)</a></li>
    </ul>
  </li>
  <li><a href="#version-3-and-beyond" id="markdown-toc-version-3-and-beyond">Version 3 and Beyond</a></li>
</ul>

<h2 id="overview">Overview</h2>

<p>WaterMe is the only app that I have released on the App Store that got any sort
of usage traction at all. It doesn’t have a lot of users, but at the time of
this writing (September 2025) it had 993K total sessions according to App Store
Connect analytics. Since these analytics are opt-in I assume that means its had
about 3M total sessions… which is still not a lot, but for a nice little hobby
app, I think its pretty cool <i class="fa-regular fa-hand-peace"></i></p>

<h3 id="app-store-description">App Store Description</h3>

<p>Never let another plant turn brown again. WaterMe reminds you when to tend to
the plants in your garden:</p>

<ol>
  <li>Add your plants into the app.</li>
  <li>Add reminders for watering, fertilizing, etc.</li>
  <li>Get 1 notification every day reminding you which plants need care.</li>
  <li>Take care of the plant in real life.</li>
  <li>Drag and drop the reminder to mark it as complete.</li>
</ol>

<p>Thats it! Every day you’ll get one, and only one, notification that reminds you
to take care of your plants.</p>

<ul>
  <li>Supports multiple kinds of reminders per plant
    <ul>
      <li>Water, Fertilize, Trim, and more</li>
    </ul>
  </li>
  <li>Easy to see which plants need to be taken care of and when.</li>
  <li>Syncs data across all of your iOS devices via iCloud.</li>
  <li>Supports working quickly with Drag and Drop interface.</li>
  <li>Customize the time notifications are sent every day.</li>
  <li>Care for your garden with your voice using Siri Shortcuts.</li>
  <li>Tip Jar In-App Purchases allow you to directly support the development of WaterMe.</li>
  <li>Supports Split Screen and Slide Over iPad Multitasking.</li>
  <li>Supports Dynamic Type.</li>
  <li>Supports Voiceover and other iOS accessibility features.</li>
</ul>

<h3 id="download">Download</h3>

<ul>
  <li><a href="https://apps.apple.com/us/app/waterme-gardening-reminders/id1089742494" target="_blank"><i class="fa-brands fa-app-store"></i>App Store</a></li>
  <li><a href="https://github.com/jeffreybergier/WaterMe/" target="_blank"><i class="fa-brands fa-github"></i>WaterMe Source Code</a></li>
  <li><a href="https://bitbucket.org/saturdayapps/waterme/" target="_blank"><i class="fa-brands fa-bitbucket"></i>WaterMe Source Code (Outdated)</a></li>
</ul>

<h2 id="development">Development</h2>

<p>WaterMe was the first ever app I wrote that is 100% a <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> 
app. Its just a database app with a pretty user interface placed on top of it.
I also got help from a designer friend to make the watering animation video as
well as the icon. Its written entirely in Swift and UIKit but has gone through
a lot of iterations over the years.</p>

<h3 id="version-1-2016">Version 1 (2016)</h3>

<p>The original version of WaterMe was extremely simple and the Core Data model was
simple to match. You had a plant with a name, photo, last watered date, and
watering interval. The app would then sort them categorize them as needing
“Water Today”, “Water Tomorrow”, or “Water Later.” As this was the days of iOS
10, the user interface was also extremely simple.</p>

<table>
  <tbody>
    <tr>
      <td><a href="/assets/images/apps/waterme/v1/01-full.png"><img src="/assets/images/apps/waterme/v1/01-thumb.png" alt="WaterMe v1 Screenshot 1" /></a></td>
      <td><a href="/assets/images/apps/waterme/v1/02-full.png"><img src="/assets/images/apps/waterme/v1/02-thumb.png" alt="WaterMe v1 Screenshot 2" /></a></td>
      <td><a href="/assets/images/apps/waterme/v1/03-full.png"><img src="/assets/images/apps/waterme/v1/03-thumb.png" alt="WaterMe v1 Screenshot 3" /></a></td>
      <td><a href="/assets/images/apps/waterme/v1/04-full.png"><img src="/assets/images/apps/waterme/v1/04-thumb.png" alt="WaterMe v1 Screenshot 4" /></a></td>
      <td><a href="/assets/images/apps/waterme/v1/05-full.png"><img src="/assets/images/apps/waterme/v1/05-thumb.png" alt="WaterMe v1 Screenshot 5" /></a></td>
    </tr>
  </tbody>
</table>

<h3 id="version-2-2017">Version 2 (2017)</h3>

<p>This version was a major rewrite where I updated the data model to be more
sophisticated. In v2.0, the data model included a hierarchy that allowed each
plant to contain multiple reminders each of which had their own watering
history. Also each plant and each reminder also had a type. For reminders, this
resulted in watering, trimming, or other. But for the plant this field remains
unusued. But I added it so that theoretically types could be added for other
househeld reminders like clothes or something.</p>

<p>This update took advantage of the new drag and drop support that was
added in iOS 11 to make it possible to perform multiple reminders at once.
Lastly, I changed to the database to Realm in the hopes that I could one day
add multi-device syncing.</p>

<table>
  <tbody>
    <tr>
      <td><a href="/assets/images/apps/waterme/v2.0/01-full.png"><img src="/assets/images/apps/waterme/v2.0/01-thumb.png" alt="WaterMe v2.0 Screenshot 1" /></a></td>
      <td><a href="/assets/images/apps/waterme/v2.0/02-full.png"><img src="/assets/images/apps/waterme/v2.0/02-thumb.png" alt="WaterMe v2.0 Screenshot 2" /></a></td>
      <td><a href="/assets/images/apps/waterme/v2.0/03-full.png"><img src="/assets/images/apps/waterme/v2.0/03-thumb.png" alt="WaterMe v2.0 Screenshot 3" /></a></td>
      <td><a href="/assets/images/apps/waterme/v2.0/04-full.png"><img src="/assets/images/apps/waterme/v2.0/04-thumb.png" alt="WaterMe v2.0 Screenshot 4" /></a></td>
      <td><a href="/assets/images/apps/waterme/v2.0/05-full.png"><img src="/assets/images/apps/waterme/v2.0/05-thumb.png" alt="WaterMe v2.0 Screenshot 5" /></a></td>
    </tr>
  </tbody>
</table>

<h3 id="version-25-2020">Version 2.5 (2020)</h3>

<p>This version brought few UI changes, but completely changed the database under
the hood. In 2019 with iOS 13, Apple released
<a href="https://developer.apple.com/documentation/coredata/nspersistentcloudkitcontainer"><code class="language-plaintext highlighter-rouge">NSPersistentCloudKitContainer</code></a> 
which allowed syncing Core Data reliably via CloudKit. I really wanted to
provide syncing to my users so I started the process of swapping the database
layer. This involved writing a wrapper for Realm and Core Data so the UI would
not know the difference. As well, I had to write a one-time migration capability
that would do the terrifying work of performing the migration.</p>

<p>At this time I also added error reporting using a hacked together (but free)
system built with AWS Simple Email Service. It would just send a JSON payload to
AWS Lambda, and that would use the Simple Email Service to email me the errors.
This way I would know if the database migrations were failing.</p>

<table>
  <tbody>
    <tr>
      <td><a href="/assets/images/apps/waterme/v2.5/01-full.png"><img src="/assets/images/apps/waterme/v2.5/01-thumb.png" alt="WaterMe Screenshot 1" /></a></td>
      <td><a href="/assets/images/apps/waterme/v2.5/02-full.png"><img src="/assets/images/apps/waterme/v2.5/02-thumb.png" alt="WaterMe Screenshot 2" /></a></td>
      <td><a href="/assets/images/apps/waterme/v2.5/03-full.png"><img src="/assets/images/apps/waterme/v2.5/03-thumb.png" alt="WaterMe Screenshot 3" /></a></td>
      <td><a href="/assets/images/apps/waterme/v2.5/04-full.png"><img src="/assets/images/apps/waterme/v2.5/04-thumb.png" alt="WaterMe Screenshot 4" /></a></td>
      <td><a href="/assets/images/apps/waterme/v2.5/05-full.png"><img src="/assets/images/apps/waterme/v2.5/05-thumb.png" alt="WaterMe Screenshot 5" /></a></td>
    </tr>
  </tbody>
</table>

<h2 id="version-3-and-beyond">Version 3 and Beyond</h2>

<p>In 2024, I worked on a new version of WaterMe with an all new UI in SwiftUI.
I created it to actually make an Apple Watch version of the app. Its mostly 
complete but other projects caught my interest and I have yet to finish and
release it. I would also like to reuse the UI for the iPhone version as I really
dislike working in UIKit. However, I am not sure if I will get the interest
again to do this work.</p>

<p>I am at a crossing point where I could just let WaterMe fade away due updates 
needed for Liquid Glass or inevitable future changes, or I could keep working
on it. We shall see I suppose.</p>]]></content><author><name></name></author><category term="Apps" /><category term="Apps" /><category term="Hobby" /><summary type="html"><![CDATA[WaterMe was my first app that was 100% a CRUD app and has been on the App Store since 2016.]]></summary></entry><entry><title type="html">Gratuity: Simple Tip Calculator</title><link href="https://jeffburg.com/apps/2015/01/01/Gratuity.html" rel="alternate" type="text/html" title="Gratuity: Simple Tip Calculator" /><published>2015-01-01T00:00:00+00:00</published><updated>2015-01-01T00:00:00+00:00</updated><id>https://jeffburg.com/apps/2015/01/01/Gratuity</id><content type="html" xml:base="https://jeffburg.com/apps/2015/01/01/Gratuity.html"><![CDATA[<h2 id="overview">Overview</h2>

<p>Gratuity was an app I made to learn how to use Swift as well as how to customize
UIKit a lot. Even though it was only a simple tip calculator, I really focused
on the design to make it something unique and easy to use. I focused on how the
iPhone has a great touch screen that makes scrolling so easy. The same was true
on the Apple Watch, where the digital crown makes scrolling just as easy. So
yes, I managed to make a tip calculator that does not use keyboard or keypad
input at all.</p>

<h3 id="download">Download</h3>

<p>Unfortunately, Gratuity is no longer available on the App Store, but you can
download the source with the link below. That said, I am not sure how easy it
will be to compile as Swift as well as the Watch Extension API’s have changed
so much over the years.</p>

<ul>
  <li><a href="https://bitbucket.org/saturdayapps/gratuity/" target="_blank"><i class="fa-brands fa-bitbucket"></i>Gratuity Source Code (Outdated)</a></li>
</ul>

<h3 id="table-of-contents">Table of Contents</h3>

<ul id="markdown-toc">
  <li><a href="#overview" id="markdown-toc-overview">Overview</a>    <ul>
      <li><a href="#download" id="markdown-toc-download">Download</a></li>
      <li><a href="#table-of-contents" id="markdown-toc-table-of-contents">Table of Contents</a></li>
    </ul>
  </li>
  <li><a href="#development" id="markdown-toc-development">Development</a>    <ul>
      <li><a href="#watch-app-version-11" id="markdown-toc-watch-app-version-11">Watch App Version 1.1</a></li>
      <li><a href="#watch-app-version-12" id="markdown-toc-watch-app-version-12">Watch App Version 1.2</a></li>
    </ul>
  </li>
  <li><a href="#current-status" id="markdown-toc-current-status">Current Status</a></li>
</ul>

<h2 id="development">Development</h2>

<p>The first app I wrote was before Swift was announced, so it was written in
Objective-C. But with Gratuity I wanted to learn Swift. Needless to say, it was
not the greatest Swift code. Also, it went through the extremely painful “Great
Renaming” when Swift 2.0 came out. Also, I made heavy use of the custom
<code class="language-plaintext highlighter-rouge">UIViewController</code> transition API. Its a big pain in the ass, but it can really
create some beautiful effects. You really need to watch the 
<a href="/assets/images/apps/gratuity/phone/vid-full.mp4">demonstration video</a>
in order to see all of the custom effects I built into Gratuity. All of that
combined meant that the codebase is not beautiful and is difficult to maintain.
But that is often the tradeoffs developers need to make. On one hand, you can
have beautiful and clean code with no frills and on the other, you have a big
jumble of code that gives you the design you seek.</p>

<p>Lastly, at this time WatchKit was brand new and extremely limited. It was
honestly a giant pain to work with and I ended up rewriting the watch UI twice
as WatchKit 1.0 was so limiting, I could barely make the app work at all.</p>

<h3 id="watch-app-version-11">Watch App Version 1.1</h3>

<p>In WatchKit 1.0, the only way to make a list scroll with the digital crown was
to have the list be the only list on the screen. Thus if I had to make every
step of the app a full screen. Also, the List view API did not do cell recycling
as it did on the iPhone. So each list had to be extremely short or else the the
screen would take forever to load. Considering the limitations, I think the
results came out good, but I wanted more!</p>

<table>
  <tbody>
    <tr>
      <td><a href="/assets/images/apps/gratuity/watch/v1.1-vid-full.mp4"><img src="/assets/images/apps/gratuity/watch/v1.1-vid-thumb.png" alt="Watch v1.1 Video 1" /></a></td>
      <td><a href="/assets/images/apps/gratuity/watch/v1.1-01-full.png"><img src="/assets/images/apps/gratuity/watch/v1.1-01-thumb.png" alt="Watch v1.1 Screenshot 1" /></a></td>
      <td><a href="/assets/images/apps/gratuity/watch/v1.1-02-full.png"><img src="/assets/images/apps/gratuity/watch/v1.1-02-thumb.png" alt="Watch v1.1 Screenshot 2" /></a></td>
      <td><a href="/assets/images/apps/gratuity/watch/v1.1-03-full.png"><img src="/assets/images/apps/gratuity/watch/v1.1-03-thumb.png" alt="Watch v1.1 Screenshot 3" /></a></td>
      <td><a href="/assets/images/apps/gratuity/watch/v1.1-04-full.png"><img src="/assets/images/apps/gratuity/watch/v1.1-04-thumb.png" alt="Watch v1.1 Screenshot 4" /></a></td>
    </tr>
  </tbody>
</table>

<h3 id="watch-app-version-12">Watch App Version 1.2</h3>

<p>I am not entirely sure which WatchKit update allowed for the use of picker
controls, but this is exactly the update I needed. With this new control,
the watch app could be laid out like the iPhone app and work in the exact same
way. This was so much better I was able to remove the tutorial I worked so hard
on in v1.1.</p>

<table>
  <tbody>
    <tr>
      <td><a href="/assets/images/apps/gratuity/watch/v1.2-01-full.png"><img src="/assets/images/apps/gratuity/watch/v1.2-01-thumb.png" alt="Watch v1.2 Screenshot 1" /></a></td>
      <td><a href="/assets/images/apps/gratuity/watch/v1.2-02-full.png"><img src="/assets/images/apps/gratuity/watch/v1.2-02-thumb.png" alt="Watch v1.2 Screenshot 2" /></a></td>
      <td><a href="/assets/images/apps/gratuity/watch/v1.2-03-full.png"><img src="/assets/images/apps/gratuity/watch/v1.2-03-thumb.png" alt="Watch v1.2 Screenshot 3" /></a></td>
      <td><a href="/assets/images/apps/gratuity/watch/v1.2-04-full.png"><img src="/assets/images/apps/gratuity/watch/v1.2-04-thumb.png" alt="Watch v1.2 Screenshot 4" /></a></td>
    </tr>
  </tbody>
</table>

<h2 id="current-status">Current Status</h2>

<p>I unfortunately retired Gratuity several years ago. There were several reasons
for this:</p>

<ol>
  <li>It never got much usage: It was free, but that does not mean people will find
  and use your app</li>
  <li>It was difficult to maintain: Because of the WatchKit extension, it was
  difficult to maintain and test. Especially since the WatchKit API kept getting
scrapped and rewritten by Apple.</li>
  <li>I moved to Japan: I no longer needed a tip calculator <i class="fa-solid fa-face-grin-squint-tears"></i></li>
</ol>]]></content><author><name></name></author><category term="Apps" /><category term="Apps" /><category term="Hobby" /><summary type="html"><![CDATA[Gratuity was a tip calculator where I got to go wild with the design and make something totally unique]]></summary></entry><entry><title type="html">QoS Redesign</title><link href="https://jeffburg.com/design/2014/01/01/QoS.html" rel="alternate" type="text/html" title="QoS Redesign" /><published>2014-01-01T00:00:00+00:00</published><updated>2014-01-01T00:00:00+00:00</updated><id>https://jeffburg.com/design/2014/01/01/QoS</id><content type="html" xml:base="https://jeffburg.com/design/2014/01/01/QoS.html"><![CDATA[<h2 id="project">Project</h2>
<p>The QoS feature of the SteelHead was being re-implemented and so it was due for
a redesign. QoS is extremely complex and the design process was long. But it was
an incredible success. Through extensive UX research and design, we proposed a
new mental model for QoS in the SteelHead.</p>

<ul id="markdown-toc">
  <li><a href="#project" id="markdown-toc-project">Project</a>    <ul>
      <li><a href="#feature-research" id="markdown-toc-feature-research">Feature Research</a></li>
      <li><a href="#user-research" id="markdown-toc-user-research">User Research</a></li>
      <li><a href="#sites" id="markdown-toc-sites">Sites</a></li>
      <li><a href="#classes" id="markdown-toc-classes">Classes</a></li>
      <li><a href="#rules" id="markdown-toc-rules">Rules</a></li>
      <li><a href="#profiles" id="markdown-toc-profiles">Profiles</a></li>
    </ul>
  </li>
  <li><a href="#experimentation" id="markdown-toc-experimentation">Experimentation</a>    <ul>
      <li><a href="#qos-class-feedback" id="markdown-toc-qos-class-feedback">QoS Class Feedback</a></li>
      <li><a href="#uplink-variations" id="markdown-toc-uplink-variations">Uplink Variations</a></li>
      <li><a href="#dashboard-widget" id="markdown-toc-dashboard-widget">Dashboard Widget</a></li>
    </ul>
  </li>
</ul>

<h3 id="feature-research">Feature Research</h3>
<p><a href="/assets/images/design/qos/feature-2k.png" class="thumbnail"><img src="/assets/images/design/qos/feature-600.png" alt="Screenshot" /></a>
QoS is an enormously complex feature. The first step in the process was to fully
understand how QoS works, what its intended to do, and what is needed to make it
do that. I learned everything from the HFSC algorithm, QoS classes, deep packet
inspection, latency priority, minimum and maximum bandwidth, etc. It got to the
point where the questions I asked of the engineers couldn’t be answered without
looking into their source code.</p>

<h3 id="user-research">User Research</h3>
<p><a href="/assets/images/design/qos/user-2k.png" class="thumbnail"><img src="/assets/images/design/qos/user-600.png" alt="Screenshot" /></a>
After learning everything there is to know about how QoS works, it was time to
speak with network administrators to see how they actually use it. I went onsite
at several companies in Illinois, Montreal, and the UK. The user researcher and
I also conducted remote interviews of many more firms. We learned what they used
QoS for, what issues they had with the current version of QoS, and what they
wanted to do with the QoS feature in the future.</p>

<h3 id="sites">Sites</h3>
<p><a href="/assets/images/design/qos/sites-2k.png" class="thumbnail"><img src="/assets/images/design/qos/sites-600.png" alt="Screenshot" /></a>
QoS needs to know the speeds of every network connection in the system. It needs
to know this so it can adequately divide up resources. Network administrators
have hundreds, or even thousands of locations. And each location can have
multiple network connections. So I created an entire concept around this called
‘Sites.’ Each site has any number of uplinks (network connections) and each
uplink has upstream and downstream bandwidths associated with them. This gives
the QoS system the information it needs on bandwidth restrictions across the
entire network.</p>

<h3 id="classes">Classes</h3>
<p><a href="/assets/images/design/qos/classes-2k.png" class="thumbnail"><img src="/assets/images/design/qos/classes-600.png" alt="Screenshot" /></a>
QoS systems usually have the concept of classes. Classes are sort of like
buckets. The network administrator puts certain applications into certain
buckets, then the system treats each bucket with a certain level of importance.
The most important thing to remember about these buckets, is that giving one
more resources, necessarily gives the others less. Also, putting all traffic
into an important bucket may not be desirable. QoS works by prioritizing
important traffic over less important traffic. If all traffic is marked as
important, it can’t do that. Concerns like this were common from network
administrators. I attempted to produce UI’s that could show some of this
information in a visual way, but in the end, we settled for a fairly simple tree
visualization. A few slides after this, there are some concepts I made for
visually showing class information.</p>

<h3 id="rules">Rules</h3>
<p><a href="/assets/images/design/qos/classes-2k.png" class="thumbnail"><img src="/assets/images/design/qos/classes-600.png" alt="Screenshot" /></a>
QoS classes are like buckets you put Apps into that then get managed by the QoS
system. Rules are the mechanism by which the network administrator puts apps
into the classes. Because SteelHead has incredibly powerful Deep Packet
Inspection (DPI) technology. Specifying apps is very easy. Users can search for
commonly known app names, as opposed to intricate IP address and port mappings.
Also, our team pre-grouped the apps into about 8 groups. Each group contains
approximately 800 applications. The rules can be specified with an individual
app or an individual app group. This makes configuring QoS extremely fast.</p>

<h3 id="profiles">Profiles</h3>
<p><a href="/assets/images/design/qos/profiles-2k.png" class="thumbnail"><img src="/assets/images/design/qos/profiles-600.png" alt="Screenshot" /></a>
QoS profiles are how you connect QoS Classes and Rules and Sites. The
SteelCentral Controller has a birds-eye view of all the SteelHeads on a
customer’s network. We designed the profiles UI to take advantage of this extra
knowledge. We did this by having the network administrator choose a source and
destination site, or group of sites, that each profile applies to. With this
information, the SteelCentral Controller knows how to distribute the QoS
Profiles to all appliances automatically. This simplification makes QoS
configuration far more declarative. This is something we strive for. We call it
‘intent’ based management. Where the network administrator specifies <strong>what</strong>
they want, rather than <strong>how</strong> to make it happen. This is an incredibly powerful
paradigm for the new QoS feature.</p>

<h2 id="experimentation">Experimentation</h2>
<p>As with all products and features, not everything the design team makes, makes
it into the product. Sometimes they’re features that are not needed, sometimes
they are too complex, and sometimes they are just way too cool. Below are some
experiments that I made that never shipped.</p>

<h3 id="qos-class-feedback">QoS Class Feedback</h3>
<p><a href="/assets/images/design/qos/profile-experiment1-2k.png" class="thumbnail"><img src="/assets/images/design/qos/profile-experiment1-600.png" alt="Screenshot" /></a>
Setting the min and max bandwidth allocations for a QoS class is kind of a
guessing game. Set the numbers and see how it goes. In order to alleviate
this, I attempted to create some mockups with configurations that would
advise the user of issues with the classes and tried to summarize their
congestion over time in a visual way.</p>

<h3 id="uplink-variations">Uplink Variations</h3>
<p><a href="/assets/images/design/qos/profile-experiment2-2k.png" class="thumbnail"><img src="/assets/images/design/qos/profile-experiment2-600.png" alt="Screenshot" /></a>
Uplink Variations are a system where the network admin could select
different QoS Class min and max assignments based on the Uplink that was
being used. This is important when one or more network connections fail at a
site. In those conditions, critical traffic needs a higher priority.</p>

<h3 id="dashboard-widget">Dashboard Widget</h3>
<p><a href="/assets/images/design/qos/dashboard-experiment-2k.png" class="thumbnail"><img src="/assets/images/design/qos/dashboard-experiment-600.png" alt="Screenshot" /></a>
SteelCentral Controller has really great dashboards that give an overview of
what is going on on your network. This is one mockups I made of what a QoS
widget could have looked at. It shows the QoS classes. When a class is
expanded, it shows relevant errors and warnings.</p>]]></content><author><name></name></author><category term="Design" /><category term="Design" /><category term="Professional" /><summary type="html"><![CDATA[Redesign QoS on SteelHead and SteelCentral Controller for greater flexibility and improved simplicity.]]></summary></entry></feed>